# Reflection: How AI Impacted My Build Process

Using AI during my build process changed the way I approached coding and problem-solving. It gave me momentum in moments when I would have otherwise felt stuck, and it highlighted the value of prompting, reviewing, and iterating carefully. My recent experience building and deploying a project with Vercel made these lessons even clearer, especially when I encountered repeated deployment errors.

One area where AI really helped was in scaffolding and speeding up development. When I was working on my UI components, such as the select dropdown, I could quickly ask AI to generate clean component code. Instead of spending hours looking for examples online or second-guessing syntax, I had a functional draft within minutes. That gave me a base to refine rather than a blank page to overcome. This efficiency carried over to other parts of the build process too—whether setting up configuration files or checking the right structure for a Next.js app.

AI also proved valuable in diagnosing errors when my deployment kept failing on Vercel. For example, I kept getting the “Module not found: Can’t resolve './ui/select'” error, even after multiple fixes. Locally the code worked fine, so it was frustrating that Vercel kept rejecting it. Sharing the logs with AI helped me realize the problem was case sensitivity. On my machine, `select.tsx` and `Select.tsx` looked the same, but on Vercel’s Linux servers they were completely different. Without AI pointing me in that direction, I might have kept chasing unrelated fixes. This taught me how important small details like file naming conventions are in real-world deployments.

That said, AI had its limitations. Sometimes the suggestions it gave were too generic, or they only partially solved the issue. At one point, I felt like I was applying fix after fix only to face another “static” issue in the logs. This showed me that AI is not a silver bullet. It can suggest, guide, and explain, but the responsibility to test, validate, and adapt the solution remains mine. In fact, those moments where I had to slow down and carefully review what AI proposed were when I learned the most.

Prompting also stood out as a skill I had to practice. When I asked vague questions like “why won’t this work?”, the responses were often broad and unhelpful. But when I included the exact error logs, file paths, or deployment steps I had already tried, AI gave me much sharper insights. This taught me to communicate with AI the way I would with a senior developer—clear, detailed, and context-rich.

The cycle of prompting, reviewing, and iterating became the rhythm of my build process. Each time AI gave me a possible fix, I would implement it, redeploy, and check results. If it didn’t work, I went back with more context. This iterative loop not only solved my immediate problems but also deepened my understanding of how build systems, file structures, and deployments work.

Overall, I learned that AI is best seen as a collaborator. It can accelerate development, reduce frustration, and highlight issues I might overlook. But it also forces me to think critically, to refine my communication, and to take ownership of the final outcome. AI impacted my build process by making me faster, but more importantly, it made me more reflective and resilient as a developer.
